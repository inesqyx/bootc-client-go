// Code generated by github.com/atombender/go-jsonschema, DO NOT EDIT.

package client

import "encoding/json"
import "fmt"

// A bootable entry
type BootEntry struct {
	// The last fetched cached update metadata
	CachedUpdate interface{} `json:"cachedUpdate,omitempty" yaml:"cachedUpdate,omitempty" mapstructure:"cachedUpdate,omitempty"`

	// The image reference
	Image interface{} `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`

	// Whether this boot entry is not compatible (has origin changes bootc does not
	// understand)
	Incompatible bool `json:"incompatible" yaml:"incompatible" mapstructure:"incompatible"`

	// If this boot entry is ostree based, the corresponding state
	Ostree interface{} `json:"ostree,omitempty" yaml:"ostree,omitempty" mapstructure:"ostree,omitempty"`

	// Whether this entry will be subject to garbage collection
	Pinned bool `json:"pinned" yaml:"pinned" mapstructure:"pinned"`

	// The container storage backend
	Store interface{} `json:"store,omitempty" yaml:"store,omitempty" mapstructure:"store,omitempty"`
}

// A bootable entry
type BootEntryOstree struct {
	// The ostree commit checksum
	Checksum string `json:"checksum" yaml:"checksum" mapstructure:"checksum"`

	// The deployment serial
	DeploySerial int `json:"deploySerial" yaml:"deploySerial" mapstructure:"deploySerial"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BootEntryOstree) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["checksum"]; raw != nil && !ok {
		return fmt.Errorf("field checksum in BootEntryOstree: required")
	}
	if _, ok := raw["deploySerial"]; raw != nil && !ok {
		return fmt.Errorf("field deploySerial in BootEntryOstree: required")
	}
	type Plain BootEntryOstree
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BootEntryOstree(plain)
	return nil
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *BootEntry) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["incompatible"]; raw != nil && !ok {
		return fmt.Errorf("field incompatible in BootEntry: required")
	}
	if _, ok := raw["pinned"]; raw != nil && !ok {
		return fmt.Errorf("field pinned in BootEntry: required")
	}
	type Plain BootEntry
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = BootEntry(plain)
	return nil
}

// Configuration for system boot ordering.
type BootOrder interface{}

// The host specification
type HostSpec struct {
	// If set, and there is a rollback deployment, it will be set for the next boot.
	BootOrder interface{} `json:"bootOrder,omitempty" yaml:"bootOrder,omitempty" mapstructure:"bootOrder,omitempty"`

	// The host image
	Image interface{} `json:"image,omitempty" yaml:"image,omitempty" mapstructure:"image,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HostSpec) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain HostSpec
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["bootOrder"]; !ok || v == nil {
		plain.BootOrder = "default"
	}
	*j = HostSpec(plain)
	return nil
}

// The status of the host system
type HostStatus struct {
	// The booted image; this will be unset if the host is not bootc compatible.
	Booted interface{} `json:"booted,omitempty" yaml:"booted,omitempty" mapstructure:"booted,omitempty"`

	// The previously booted image
	Rollback interface{} `json:"rollback,omitempty" yaml:"rollback,omitempty" mapstructure:"rollback,omitempty"`

	// Set to true if the rollback entry is queued for the next boot.
	RollbackQueued bool `json:"rollbackQueued,omitempty" yaml:"rollbackQueued,omitempty" mapstructure:"rollbackQueued,omitempty"`

	// The staged image for the next boot
	Staged interface{} `json:"staged,omitempty" yaml:"staged,omitempty" mapstructure:"staged,omitempty"`

	// The detected type of system
	Type interface{} `json:"type,omitempty" yaml:"type,omitempty" mapstructure:"type,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *HostStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	type Plain HostStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["rollbackQueued"]; !ok || v == nil {
		plain.RollbackQueued = false
	}
	*j = HostStatus(plain)
	return nil
}

// The detected type of running system.  Note that this is not exhaustive and new
// variants may be added in the future.
type HostType interface{}

// A container image reference with attached transport and signature verification
type ImageReference struct {
	// The container image reference
	Image string `json:"image" yaml:"image" mapstructure:"image"`

	// Signature verification type
	Signature interface{} `json:"signature,omitempty" yaml:"signature,omitempty" mapstructure:"signature,omitempty"`

	// The container image transport
	Transport string `json:"transport" yaml:"transport" mapstructure:"transport"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImageReference) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["image"]; raw != nil && !ok {
		return fmt.Errorf("field image in ImageReference: required")
	}
	if _, ok := raw["transport"]; raw != nil && !ok {
		return fmt.Errorf("field transport in ImageReference: required")
	}
	type Plain ImageReference
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImageReference(plain)
	return nil
}

// An image signature
type ImageSignature interface{}

// The status of the booted image
type ImageStatus struct {
	// The currently booted image
	Image interface{} `json:"image" yaml:"image" mapstructure:"image"`

	// The digest of the fetched image (e.g. sha256:a0...);
	ImageDigest string `json:"imageDigest" yaml:"imageDigest" mapstructure:"imageDigest"`

	// The build timestamp, if any
	Timestamp *time.Time `json:"timestamp,omitempty" yaml:"timestamp,omitempty" mapstructure:"timestamp,omitempty"`

	// The version string, if any
	Version *string `json:"version,omitempty" yaml:"version,omitempty" mapstructure:"version,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *ImageStatus) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["image"]; raw != nil && !ok {
		return fmt.Errorf("field image in ImageStatus: required")
	}
	if _, ok := raw["imageDigest"]; raw != nil && !ok {
		return fmt.Errorf("field imageDigest in ImageStatus: required")
	}
	type Plain ImageStatus
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	*j = ImageStatus(plain)
	return nil
}

type ObjectMeta struct {
	// Annotations corresponds to the JSON schema field "annotations".
	Annotations ObjectMetaAnnotations `json:"annotations,omitempty" yaml:"annotations,omitempty" mapstructure:"annotations,omitempty"`

	// Labels corresponds to the JSON schema field "labels".
	Labels ObjectMetaLabels `json:"labels,omitempty" yaml:"labels,omitempty" mapstructure:"labels,omitempty"`

	// Name corresponds to the JSON schema field "name".
	Name *string `json:"name,omitempty" yaml:"name,omitempty" mapstructure:"name,omitempty"`

	// Namespace corresponds to the JSON schema field "namespace".
	Namespace *string `json:"namespace,omitempty" yaml:"namespace,omitempty" mapstructure:"namespace,omitempty"`
}

type ObjectMetaAnnotations map[string]string

type ObjectMetaLabels map[string]string

// The core host definition
type SchemaJson struct {
	// ApiVersion corresponds to the JSON schema field "apiVersion".
	ApiVersion string `json:"apiVersion" yaml:"apiVersion" mapstructure:"apiVersion"`

	// Kind corresponds to the JSON schema field "kind".
	Kind string `json:"kind" yaml:"kind" mapstructure:"kind"`

	// Metadata corresponds to the JSON schema field "metadata".
	Metadata interface{} `json:"metadata,omitempty" yaml:"metadata,omitempty" mapstructure:"metadata,omitempty"`

	// The spec
	Spec interface{} `json:"spec,omitempty" yaml:"spec,omitempty" mapstructure:"spec,omitempty"`

	// The status
	Status interface{} `json:"status,omitempty" yaml:"status,omitempty" mapstructure:"status,omitempty"`
}

// UnmarshalJSON implements json.Unmarshaler.
func (j *SchemaJson) UnmarshalJSON(b []byte) error {
	var raw map[string]interface{}
	if err := json.Unmarshal(b, &raw); err != nil {
		return err
	}
	if _, ok := raw["apiVersion"]; raw != nil && !ok {
		return fmt.Errorf("field apiVersion in SchemaJson: required")
	}
	if _, ok := raw["kind"]; raw != nil && !ok {
		return fmt.Errorf("field kind in SchemaJson: required")
	}
	type Plain SchemaJson
	var plain Plain
	if err := json.Unmarshal(b, &plain); err != nil {
		return err
	}
	if v, ok := raw["metadata"]; !ok || v == nil {
		plain.Metadata = map[string]interface{}{}
	}
	if v, ok := raw["spec"]; !ok || v == nil {
		plain.Spec = map[string]interface{}{
			"bootOrder": "default",
			"image":     nil,
		}
	}
	if v, ok := raw["status"]; !ok || v == nil {
		plain.Status = map[string]interface{}{
			"booted":         nil,
			"rollback":       nil,
			"rollbackQueued": false,
			"staged":         nil,
			"type":           nil,
		}
	}
	*j = SchemaJson(plain)
	return nil
}

// The container storage backend
type Store interface{}
